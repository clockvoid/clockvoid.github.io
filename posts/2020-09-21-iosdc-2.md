---
title: iOSDC 2020 2日目
github-link: posts/2020-09-21-iosdc-2.md
summary: iOSDC 2020 2日目で気になったセッションや初めて知ったことをまとめます
---

# The Composable Architeecture
TCAと略される

ライブラリとして提供されており，Fluxっぽいアーキテクチャを難しいことがわからなくてもかんたんに構築できる．

[GitHub](https://github.com/pointfreeco/swift-composable-architecture )

ケースタディとしていくつかのサンプルが公開されている

## 特徴
- State management
- Composition
- Side effects
- Testing
- Ergonomics

## ケーススタディ
- EffectsBasic
  - プラスとマイナスボタンがあり，マイナスがタップされると1秒後に自動的にプラスされ，戻される
  - 更に，Number Factボタンが有り，それを押すと今のカウントでWebAPIを呼び出す
  - Reducer
    - マイナスボタンが呼び出されると，delayが入ったEffectを作って返している
    - Number Factボタンが呼び出されると，現在のstateに対してAPIを呼び出し，返り値をEffectにmapして流している
      - 成功するとSuccess，失敗するとFailureが流れるようになっている

- Stateを変更できるのはReducerのみ
- Viewとロジックをひとまとめにして，それを部品として組み合わせられる
- 大きなReducerを並べなくて良い
- 副作用はEffect型にして，次のエフェクトも繋げられる

## 中で何をしているのか
- WithViewStore
  - 内部としてはSwiftUIのView
  - 外からStoreを入れて，中でViewStoreにしている
  - ViewStoreとは，ObservedObject→SwiftUIと相性が良い
- ViewStore
  - ObservedObjectのwillChange時にStateを送れるようになっている
- Effect
  - CombineのPublisherに準拠している
  - TCA内部でSubscriber監視できる
  - オペレーターで処理をチェインできる
  - StoreはViewStoreからActionを呼び出すと，現在のActionのキューに保存
  - Actionを順次呼び出し
  - Effectを順次実行

## テストコード
どういうふうにテストを書くかが明文化されている

ActionによってReducerがStateを期待通り変更できるか？が知りたい
→ニセのEffectを入れることが可能．テスト用のScheduerもある．

Effectに対するテストを書きたいときは，単体テストを書くと良い

まずTestStoreを作る

- Environmentにテスト用のEffectを渡す
- `store.assert`で期待するStateと比較できる
- `do`メソッドでTestScheduerを一つすすめることで，副作用が適用される
- `receive`メソッドで

- TCAはReducer用のテストコードを提供してくれる

## まとめ
- 良いところ
  - ReducerからしかStateを扱えない
  - Reducerを分割できるため，大きなReducerを作らなくて良い
  - SwiftUIでも使いやすい（UIKitで扱う方法も書いてある）
  - Combineをあんまり理解していなくても，実行と監視の恩恵がある
  - テストスケジューラとテスト方法を提供してくれる
- 難しいところ
  - ある程度Combineを理解していないと何が起こっているのかわからない
  - CombineがOSSじゃないので，Combine自体のコードが読めない
  - 基本的にはアプリ設計はTCAでやりきらないといけない（気がする）
    - 他の画面はMVVMでやるとかは難しい
    - ライブラリに依存するという覚悟はいる

Qiitaにも記事を挙げられている

- SwiftUI時代のFunctional iOS Architeectureというトークもある

## Ask-the-speaker
- Reducerはアプリ全体で一つではなく，画面ごと？
  - 厳密に言うと，画面がなくても作れるので，画面ごとではない
    - 複数Reducerがあって良い
    - 画面に紐付いていなくて良い
  - Core/DateとかでDataBaseの監視用のものを作ることがあるが，それをStore（Reducer含む）で監視することも可能
    - WithViewStoreとかは画面ごとに存在する
- Effectは細かいものをたくさん作る？
  - そう．で，サブスクライブしてつないでいく．
- API呼び出しとかは全部Effectで表現する？
  - そう．Completionとかも表現できるよ
- Effectが副作用をまとめて管理している？
  - そう
- Storeについてアクションを発行できない
  - ユニバーサルリンクのイベントとかどうするんだろう
  - SwiftUIだとiOS 14だとエントリポイントのViewがユニバーサルリンクのイベントをハンドリングしてくれそう？
  - Appのデータ持っているのはStoreで，それをwithViewStoreでViewStoreに変換する
    - スコープ作る
    - そのwithViewStoreに対してアクションを呼び出せばOK

# スモールビジネスを支えるfreeeのモバイル技術
全ては見てはいないので軽くメモ

- iOSアプリ開発ではよくUIモジュールをライブラリ化してそれを使うようにしているのを見かける
  - おそらく，テーマがないので部品をCustom Viewみたいな感じで作っておいてそれを使う感じと推測
- 「会計ドメイン」はロジックがすべてのプラットフォームで同じなので，Kotlin MPPを使用してロジック部分を共通化している
  - iOS向けにはframeworkがGradleにより生成される
  - ライブラリ呼び出しは非常に自然
- Kotlin MPPのframework生成について詳しく
  - frameworkの中には，コンパイルされたバイナリファイルとヘッダファイルが含まれている
  - バイナリはx86，arm_64などで別ディレクトリに吐き出される
  - ヘッダファイルの型などはObjective-CベースなのでSwiftから呼び出すときには成約が出てしまう
  - Kotlin MPPがKotlinとの型の差分を埋めるために定義する型も存在する
    - 例えばLongなど
    - NullableのLongはSwiftではSampleLongという型がKotlin MPPにより生成されて使用される
    - SampleLongはSampleNumberの実装で，SampleNumberはNSNumberの実装になっている
  - expect/actualで各プラットフォームに処理を委譲できる
    - でもこれやりすぎたら共通化できてなくね？（？）
    - できればCommonに全部かければ良いと思う・・・（個人的な感想）

