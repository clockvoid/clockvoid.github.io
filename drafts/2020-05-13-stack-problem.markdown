---
title: Stackの辛いポイント
updated-date: 2020-05-18
summary: |
  StackはCabalよりも新しく，一時期Cabal Hellが起こらないということで，かなり注目を浴びました．
  しかし，Stackも現れてから数年がたち，最近Stackageにライブラリの新しいバージョンが乗らないなど，問題も起こっています．
  この記事では，これらの問題について考察します．
---

# Stackとは
StackはHaskell向けのビルドツールです．
`stack.yaml`というYamlファイルで定義された依存関係を自動的に解決してくれます．

Haskellには旧来，Cabalというビルドツールが存在したのですが，これはCabal Hellという問題が起こることが指摘されており，[Haskell-Wiki](https://wiki.haskell.org/Cabal/Survival)によると，Cabalのバージョン管理に問題があるようです．

これを端的に解決するツールとして，Stackという新しいバージョン管理ツールが生まれました．
CabalはHackageというレポジトリからパッケージを取ってきますが，StackはStackageというHackageのスナップショットからパッケージを取ってくるようになっており，この仕組みによってあたかもCabal Hellは解決したかのような見た目をしています．
StackはCabalとは違い，グローバルにパッケージを管理するわけではなく，resolverごとにパッケージを管理します．resolverとは正常に依存性の解決が可能なあるバージョンのパッケージの集まりで構成されているもので，その中だけで依存性の解決を行えば，基本的には依存性の解決に失敗することはないだろう，ということのようです．，

このresolverには大きく分けて2つの種類が存在しています．

- lts：GHCのマイナーアップデートごとに更新されるLong term suppurtバージョン．
- nightly：原則として一日に一回更新されるスナップショット．

上記から分かる通り，基本的にはltsを使用したほうが無難です．理由としては，一日に一回自動的に更新されてしまうnightlyバージョンは，そのスナップショットに内部的な依存関係の不完全性を作り込んでしまっている可能性があるからです．これでは問題の根本解決にはなりません．

# Stackで起こる主な問題
上で示したとおり，StackとStackageによって依存性解決問題は解消されたように見えます．しかしながら，個人的に以下のような問題にぶち当たりました．

- Stackageのスナップショットに希望のパッケージが入っていない
- いくつかのスナップショットで開発しているプロジェクトがコンピュータ内に存在しているとGHCがいくつかインストールされ，非常に大きな容量を専有する
- （これはCabalでもそうだったが）パッケージはバイナリではなく，ソースコードの形で降ってくるのですべてのパッケージについてビルドが走り，結果として膨大な依存関係を入れてしまうとコンパイルに膨大な時間がかかる

上記の問題について一つ一つ見ていきます．

## スナップショットに希望のパッケージが入っていない
はじめに，resolverはltsで使ったほうが良いと書きましたが，現実はそう甘くはありません．

Hackageには存在するが，ltsなStackageスナップショットには存在しないパッケージが大量にあります．もし，自分が使いたいパッケージがltsに存在しなかった場合，**自分の使いたいパッケージが含まれている**nightlyスナップショットを使うことになります．

しかし，これでは本末転倒です．基本的にはltsだけが人間の手によるクリーンな依存関係解決ができるものであるため，nightlyスナップショットは度々壊れます．Hackageそのものが人間の手による依存性解決をせず，誰もが自由にパッケージを公開できる場であることがここで問題になってきてしまうのです．
